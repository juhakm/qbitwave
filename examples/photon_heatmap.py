import numpy as np
import matplotlib.pyplot as plt
from qbitwave import QBitwave,  QBitwaveND
import matplotlib.animation as animation
import math
from numba import njit

from scipy.interpolate import RegularGridInterpolator

def rich_wavefunction_2d(Nx=100, Ny=100, sigma_x=8.0, sigma_y=12.0, 
                         kx=2.0, ky=1.5, x0=-10, y0=5, phase_offset=0.3*np.pi):
    """
    Asymmetric 2D Gaussian wavefunction with tilted phase and offset center.
    Useful for testing extrapolation outside the main support.
    """
    x = np.linspace(-Nx//2, Nx//2, Nx)
    y = np.linspace(-Ny//2, Ny//2, Ny)
    X, Y = np.meshgrid(x, y, indexing='ij')

    # Asymmetric Gaussian envelope with shifted center
    amplitude = np.exp(-((X - x0)**2 / (2 * sigma_x**2) + (Y - y0)**2 / (2 * sigma_y**2)))
    
    # Tilted complex phase: diagonal wave vector
    phase = np.exp(1j * (kx * X + ky * Y + phase_offset))
    
    psi = amplitude * phase
    return psi


# Photon wavefunction: 2D Gaussian slice
def photon_wavefunction_2d(Nx=100, Ny=100, sigma=10.0, k=1.0):
    x = np.linspace(-Nx//2, Nx//2, Nx)
    y = np.linspace(-Ny//2, Ny//2, Ny)
    X, Y = np.meshgrid(x, y, indexing='ij')
    amplitude = np.exp(-(X**2 + Y**2) / (2 * sigma**2))
    phase = np.exp(1j * k * 0)  # fixed z = 0
    psi = amplitude * phase
    return psi


def photon_wavefunction_2d_moving(Nx=100, Ny=100, sigma=10.0, kx=5.0, ky=0.0, x0=-20, y0=0):
    x = np.linspace(-Nx//2, Nx//2, Nx)
    y = np.linspace(-Ny//2, Ny//2, Ny)
    X, Y = np.meshgrid(x, y, indexing='ij')
    
    amplitude = np.exp(-((X - x0)**2 + (Y - y0)**2) / (2 * sigma**2))
    phase = np.exp(1j * (kx * X + ky * Y))  # Add directional momentum
    psi = amplitude * phase
    return psi


def photon_wavefunction_two_slits(Nx=100, Ny=100, slit_sep=20, slit_width=5, kx=5.0):
    x = np.linspace(-Nx//2, Nx//2, Nx)
    y = np.linspace(-Ny//2, Ny//2, Ny)
    X, Y = np.meshgrid(x, y, indexing='ij')

    # Two slits in Y direction
    slit1 = np.exp(-((Y - slit_sep/2)**2) / (2 * slit_width**2))
    slit2 = np.exp(-((Y + slit_sep/2)**2) / (2 * slit_width**2))
    slits = slit1 + slit2
    
    envelope = np.exp(-(X + 30)**2 / (2 * 20**2))  # wavefront left of slits
    phase = np.exp(1j * kx * X)

    psi = envelope * slits * phase
    return psi


def photon_wavefunction_plane_wave(Nx=100, Ny=100, kx=5.0, ky=2.0):
    x = np.linspace(-Nx//2, Nx//2, Nx)
    y = np.linspace(-Ny//2, Ny//2, Ny)
    X, Y = np.meshgrid(x, y, indexing='ij')
    
    psi = np.exp(1j * (kx * X + ky * Y))
    return psi


def complex_test_wavefunction(Nx=100, Ny=100):
    """
    Creates a rich, aperiodic, asymmetric wavefunction with:
    - multiple Gaussian peaks
    - phase vortices
    - directional interference
    - no symmetry
    """
    x = np.linspace(-Nx//2, Nx//2, Nx)
    y = np.linspace(-Ny//2, Ny//2, Ny)
    X, Y = np.meshgrid(x, y, indexing='ij')

    # Gaussian blobs
    g1 = np.exp(-((X + 15)**2 + (Y + 5)**2) / (2 * 6.0**2)) * np.exp(1j * (0.3 * X + 0.2 * Y))
    g2 = np.exp(-((X - 10)**2 + (Y - 10)**2) / (2 * 4.0**2)) * np.exp(1j * (1.2 * X - 0.8 * Y + np.pi/3))
    g3 = np.exp(-((X)**2 + (Y - 20)**2) / (2 * 5.0**2)) * np.exp(1j * (2.0 * np.arctan2(Y, X)))  # vortex

    # Sum them with complex weights
    psi = g1 + 0.7 * g2 + 0.5j * g3

    return psi


def bleeding_wavefunction(Nx=100, Ny=100):
    """
    A non-symmetric wavefunction whose amplitude bleeds to the boundaries
    and contains multiple interfering components.
    """
    x = np.linspace(-Nx//2, Nx//2, Nx)
    y = np.linspace(-Ny//2, Ny//2, Ny)
    X, Y = np.meshgrid(x, y, indexing='ij')

    # Gaussian 1: bottom left
    g1 = np.exp(-((X + 30)**2 + (Y + 30)**2) / (2 * 12**2)) * np.exp(1j * (0.5 * X - 0.2 * Y))

    # Gaussian 2: top right, higher frequency
    g2 = np.exp(-((X - 20)**2 + (Y - 20)**2) / (2 * 10**2)) * np.exp(1j * (1.8 * X + 1.0 * Y + np.pi/4))

    # Gaussian 3: close to center, vortex
    R = np.sqrt(X**2 + Y**2) + 1e-6
    theta = np.arctan2(Y, X)
    g3 = np.exp(-(R**2) / (2 * 20**2)) * np.exp(1j * theta * 2)

    # Weighted sum
    psi = 1.0 * g1 + 0.8 * g2 + 0.6j * g3

    return psi


def bleeding_wavefunction_with_edge_amplitudes(Nx=100, Ny=100):
    """
    Wavefunction with large, off-center Gaussians that bleed into edges.
    Produces meaningful extrapolation beyond [0,1].
    """
    x = np.linspace(-Nx//2, Nx//2, Nx)
    y = np.linspace(-Ny//2, Ny//2, Ny)
    X, Y = np.meshgrid(x, y, indexing='ij')

    # Large Gaussian centered near the bottom-left corner
    g1 = np.exp(-((X + 40)**2 + (Y + 40)**2) / (2 * 30**2)) * np.exp(1j * (0.8 * X - 0.2 * Y))

    # Large Gaussian overlapping the top and right edges
    g2 = np.exp(-((X - 40)**2 + (Y - 40)**2) / (2 * 28**2)) * np.exp(1j * (1.2 * X + 0.5 * Y + np.pi / 3))

    # Rotational component centered (optional)
    R = np.sqrt(X**2 + Y**2) + 1e-6
    theta = np.arctan2(Y, X)
    g3 = np.exp(-R**2 / (2 * 50**2)) * np.exp(1j * 2 * theta)

    # Combine them
    psi = 1.0 * g1 + 0.9 * g2 + 0.5j * g3

    return psi


#psi = photon_wavefunction_2d(Nx=100, Ny=100, sigma=10.0, k=1.0)
#psi = photon_wavefunction_2d_moving(Nx=100, Ny=100, sigma=10.0)
#psi = photon_wavefunction_two_slits(Nx=100, Ny=100)
#psi =  photon_wavefunction_plane_wave(Nx=100, Ny=100, kx=5.0, ky=2.0)
#psi = rich_wavefunction_2d(Nx=100, Ny=100)
#psi = complex_test_wavefunction()
#psi = bleeding_wavefunction()
psi =  bleeding_wavefunction_with_edge_amplitudes(Nx=100, Ny=100)


# Visualize probability density
plt.imshow(np.abs(psi)**2, cmap='inferno')
plt.title("Photon Probability Density |ψ(x,y)|²")
plt.colorbar()
plt.show()




#photon_bitstring = "000000000000001111111110000000000000000000010000000000000000000000011000110000000011111111000000100000000000000000000000110001100000000000000011111111000000100000011111111111111111000000111000111111111101111111110001100000011111111101111111110001111000111111111100000000000001000000001111111111111111000000000000101111111111111111000000011000101111111100000000110001000000001111111100000000000001011000110000000000000000110001000000010000000011111111000000111000100000000011111111110001100000100000000000000000000000100000100000000000000000110001111000100000000011111111110001011000110000000011111111000001000000010000000000000000000001011000101111111101111111000001000000101111111111111111110001000000101111111110000000110001011000101111111100000000000001100000000000000000000000000000000000110000000000000000000000011000010000000011111111110000100000000000000011111111110000111000111111111100000000000001111000111111111111111111000000100000111111111111111111000000111000011111111100000000000001100000011111111111111111110001100000111111111111111111110000100000011111111100000000110001111000011111111100000000000001000000110000000000000000110001000000110000000000000000000001111000100000000000000000000001011000010000000011111111110000100000100000000011111111000001100000100000000000000000110000111000100000000011111111110001011000010000000011111111000000000001001111111111111111000000011000001111111100000000110000000000001111111100000000000010000000001111111111111111000000100001000000000000000000000000111000000000000011111111110001100001000000000000000000000010011000110000000000000000110000011000110000000011111111110001111000000000000011111111110000000000010000000011111111000010000000010000000000000000000001111000011111111101111111110000100000111111111110000000000001100000111111111111111111110000111000011111111100000000000010000000101111111111111111110000000000101111111100011001110000011000101111111100000000000010011000101111111111100110110001000001001111111111100110110001011000001111111100000000000001011000001111111100011001000001000001001111111111111111000010100000000000000000011110101111100000000000000011100001000000000001010000000000011110000000010111110000000011100001000001111000000000000010010011110000100001000000000001101100000001100001000000000000000000110000111000000000000011111111000010011000010000000001101100110000011000010000000011111111110000000000110000000010010011000010000000110000000000000000000010111000111111111111000000000000100001011111111111100000110001100001011111111111000000101111111000111111111100011111000010100000011111111111100000101111100000011111111100111111000000110111111111111100111111110001110111111111111100011111000010111000100000000001100100000001000001010000000001000001101111100000100000000010011011110001000001010000000001100100000010100000100000000001000001000001010111110000000010011011110001010111110000000010111110101111111000100000000010111110000010011000001111111110000000110000000001001111111101111111110000011000001111111101011000000010000001001111111110100111000010111000011110110110000110000001100001011110100110011011000010100000111110100110011011110000100001011110110110000110101111111000011110100101100100000001110111111110110101111001101111100000111110110101111001110000110111111110100101100100000011000000001100100010001101000000000001101100100010001101101111000000001100100001110010000000010111101100100001110010110001100001100100001101110110000000100001100100010001110010000011011000110100001101110110000011000000010100010001110010000000110111100100001110001001110001110111100100010010001101101111011000110100010010001101101111000000010100001110001001110001000001101010000110000100000011011000101010000110000100000001000001101010000110001000000001010111101010000101111011000011000000101010000110001000101111011000101010000101110111110001010111101010000101110111101111000000101010000101111011000010111000000110001101111111000010100001000110010001111000101111111000000110010010000111101111100001000110001110000000000010000001010110010001111000000010010111110110001110000000110000010111110110010010000111110000000001010110001101111111110000100001100111001101111110000011011000010111001101111110000001100001100111001101111100000001110111100111001110000001110000110111100111001110000011000011000000110111001101111100101111011000010111001110000011101111000000110111001110000001101110100000000111101010000001000011100000000111101001111110000000010111010111101010000001000000000001110111101001111110101110100000011000010001111111000011111000111000010010000000000000110111011000010001111111110001110111011000010001111110110001100001111000010010000000000011100000011000010010000001000000100001111000010010000001101110111000111000010001111110000010110111111000010001111111101111100001011000010010000000000010100001011000010010000001101111110111111000010001111110110000000001101000001110000000000011011000001000001110000000000011000001001000001110000001000010010111101000001101111111101111011000001000001101111110000010000001101000001110000001101111000001001000001101111111110000010111101000001101111110101110100000100111110110000000101110111000100111110110000000000011100000100111110101111111000001010111010111110110000000110001010111010111110110000000110001000001110111110101111111000011111000100111110101111111000001000001110111110101111111000011100000111000000110000000000011111000011000000110000000000001110111011000000101111111110000110111011000000101111111101110100000111000000101111111110000100001111000000110000000101110111000011000000101111111000001100001111000000110000000000010110111100111111110000000101111100001100111111101111111000011010111110111111101111111000010100001100111111101111111101111110111100111111110000000101111000001010111111110000000101111010111110111111110000000000011000001010111111101111111000000000010001000000010000000000000010111001000000001111111101110000000001000000001111111000100000000001000000010000000000010010111010111111110000000110000010111010111111110000000101110111000000111111110000000"
#q = QBitwaveND(photon_bitstring, shape=(0, 0), fixed_basis_size=64 )

photon = QBitwaveND.from_array(psi)
#photon.normalize()

#print("Total bitstring length:", len(photon_bitstring))
#print("Selected basis size:", photon.fixed_basis_size)
#print("Number of amplitudes:", len(photon.amplitudes))
#print("Amplitude shape:", photon.amplitudes.shape)


# Evaluate complex amplitude at center
print("ψ(0.5, 0.5) =", photon.evaluate(0.5, 0.5))
print("|ψ|² =", abs(photon.evaluate(0.5, 0.5))**2)

# debug out a few amplitudes 
for x, y in [ (0.5, 0.5), (0.25, 0.75), (1.1, -0.1) ]:
    a = photon.evaluate(x, y)
    print(f"ψ({x:.2f},{y:.2f}) = {a} → |ψ|² = {abs(a)**2}")


def unitary_evolution(photon : QBitwaveND):
    # Parameters
    time_start = 0.0
    time_end = 1.0
    time_step = 0.1

    # Evaluation grid: from -0.1 to 1.1 (extrapolating beyond [0,1])
    x_vals = np.linspace(-50, 150, 100)
    y_vals = np.linspace(-50, 150, 100)
    X, Y = np.meshgrid(x_vals, y_vals)

    for t in np.arange(time_start, time_end, time_step):
        Z = np.empty_like(X, dtype=np.float64)  # to hold probability amplitudes
        coeffs = photon.time_evolve_coeffs(t)
        for i in range(X.shape[0]):
            for j in range(X.shape[1]):
                Z[i, j] = photon.probability(X[i,j], Y[i,j], t=t, coeffs=coeffs)

        plt.clf()
        plt.imshow(Z, extent=(-0.1, 1.1, -0.1, 1.1), origin='lower', cmap='inferno')
        plt.title(f"Photon Probability Amplitude |ψ(x,y)|² at t={t:.2f}")
        plt.colorbar()
        plt.pause(0.1)  # short pause to update plot

    plt.show()
    print("Done")

    

if __name__ == "__main__":
    unitary_evolution(photon)
